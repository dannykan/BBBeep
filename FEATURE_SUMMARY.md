# 臨時用戶功能 - 實現總結

## ✅ 已實現功能

### 1. 自動創建臨時用戶

**觸發條件**：向未註冊的車牌發送提醒

**行為**：
- 系統自動為該車牌創建臨時用戶記錄
- 臨時用戶的 `phone` 格式：`temp_<車牌>_<時間戳>`
- 如果該車牌已有臨時用戶，則使用現有的，不會重複創建

### 2. 自動合併數據

**觸發條件**：真實用戶完成註冊流程（`completeOnboarding`）

**行為**：
- 檢查是否有該車牌的臨時用戶
- 如果找到，自動合併：
  - ✅ 將臨時用戶收到的所有消息轉移到真實用戶
  - ✅ 將臨時用戶的點數轉移到真實用戶
  - ✅ 更新真實用戶的車牌信息
  - ✅ 刪除臨時用戶記錄

## 📋 修改的文件

1. **`backend/src/messages/messages.service.ts`**
   - 在 `create` 方法中添加臨時用戶創建邏輯
   - 避免重複創建臨時用戶

2. **`backend/src/users/users.service.ts`**
   - 在 `completeOnboarding` 方法中添加臨時用戶合併邏輯
   - 處理消息轉移和點數轉移

## 🎯 用戶體驗改進

### 之前
- ❌ 向未註冊車牌發送消息會返回 404 錯誤
- ❌ 用戶需要等待對方註冊才能發送消息

### 現在
- ✅ 可以隨時向任何車牌發送提醒
- ✅ 消息會正常發送，不會返回錯誤
- ✅ 真實用戶註冊後自動收到所有之前發送的消息
- ✅ 不會錯過任何提醒

## 🧪 測試場景

### 場景 1：發送消息到未註冊車牌

1. 用戶 A 向車牌 "ABC-1234" 發送提醒
2. 系統自動創建臨時用戶
3. 消息成功發送 ✅

### 場景 2：真實用戶註冊

1. 車牌 "ABC-1234" 的真實用戶完成註冊
2. 系統自動合併臨時用戶數據
3. 真實用戶可以看到之前發送的所有消息 ✅

### 場景 3：多個消息

1. 用戶 A、B、C 都向車牌 "ABC-1234" 發送提醒
2. 所有消息都發送到同一個臨時用戶
3. 真實用戶註冊後，可以看到所有消息 ✅

## 🔍 技術細節

### 臨時用戶標識

```typescript
phone: `temp_${plateUpper}_${Date.now()}`
```

### 合併邏輯

```typescript
// 1. 轉移消息
await this.prisma.message.updateMany({
  where: { receiverId: tempUser.id },
  data: { receiverId: userId },
});

// 2. 轉移點數
await this.prisma.pointHistory.create({
  data: {
    userId: userId,
    type: 'bonus',
    amount: tempUser.points,
    description: '從臨時帳戶轉移的點數',
  },
});

// 3. 刪除臨時用戶
await this.prisma.user.delete({
  where: { id: tempUser.id },
});
```

## ⚠️ 注意事項

1. **臨時用戶清理**：目前沒有自動清理機制，可以考慮添加定期清理任務
2. **唯一性保證**：使用 `temp_<車牌>_<時間戳>` 確保 phone 唯一性
3. **數據完整性**：所有關聯數據（消息、點數等）都會正確轉移

## 🚀 下一步

1. **測試功能**：重啟後端，測試發送消息和註冊流程
2. **監控日誌**：觀察臨時用戶的創建和合併過程
3. **優化**：考慮添加定期清理未激活臨時用戶的任務

## 📚 相關文檔

- `TEMP_USER_FEATURE.md` - 詳細功能說明
- `API_FIX.md` - API 錯誤修復
- `TROUBLESHOOTING.md` - 故障排除指南
